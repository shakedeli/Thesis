@inproceedings{cist,
author = {Brown, Trevor and Prokopec, Aleksandar and Alistarh, Dan},
title = {Non-Blocking Interpolation Search Trees with Doubly-Logarithmic Running Time},
year = {2020},
url = {https://doi.org/10.1145/3332466.3374542},
doi = {10.1145/3332466.3374542},
booktitle = {Proceedings of the 25th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {276–291},
}

@inproceedings{case_learned_index,
author = {Kraska, Tim and Beutel, Alex and Chi, Ed H. and Dean, Jeffrey and Polyzotis, Neoklis},
title = {The Case for Learned Index Structures},
year = {2018},
url = {https://doi.org/10.1145/3183713.3196909},
booktitle = {Proceedings of the 2018 International Conference on Management of Data},
pages = {489–504},
}

@inproceedings{cormode2021relative,
  title={Relative error streaming quantiles},
  author={Cormode, Graham and Karnin, Zohar and Liberty, Edo and Thaler, Justin and Vesel{\`y}, Pavel},
  booktitle={Proceedings of the 40th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems},
  pages={96--108},
  year={2021}
}

@article{gan2018moment,
  title={Moment-based quantile sketches for efficient high cardinality aggregation queries},
  author={Gan, Edward and Ding, Jialin and Tai, Kai Sheng and Sharan, Vatsal and Bailis, Peter},
  journal={Proceedings of the VLDB Endowment},
  volume={11},
  number={11},
  pages={1647--1660},
  year={2018},
  publisher={VLDB Endowment}
}

@article{masson2019ddsketch,
  title={DDSketch: a fast and fully-mergeable quantile sketch with relative-error guarantees},
  author={Masson, Charles and Rim, Jee E and Lee, Homin K},
  journal={Proceedings of the VLDB Endowment},
  volume={12},
  number={12},
  pages={2195--2205},
  year={2019},
  publisher={VLDB Endowment}
}


@article{abraham2013scuba,
  title={Scuba: Diving into data at facebook},
  author={Abraham, Lior and Allen, John and Barykin, Oleksandr and Borkar, Vinayak and Chopra, Bhuwan and Gerea, Ciprian and Merl, Daniel and Metzler, Josh and Reiss, David and Subramanian, Subbu and others},
  journal={Proceedings of the VLDB Endowment},
  volume={6},
  number={11},
  pages={1057--1067},
  year={2013},
  publisher={VLDB Endowment}
}

@inproceedings{vartak2015seedb,
  title={Seedb: Efficient data-driven visualization recommendations to support visual analytics},
  author={Vartak, Manasi and Rahman, Sajjadur and Madden, Samuel and Parameswaran, Aditya and Polyzotis, Neoklis},
  booktitle={Proceedings of the VLDB Endowment International Conference on Very Large Data Bases},
  volume={8},
  number={13},
  pages={2182},
  year={2015},
  organization={NIH Public Access}
}

@inbook{Rinberg_2020_fast_sketches,
author = {Rinberg, Arik and Spiegelman, Alexander and Bortnikov, Edward and Hillel, Eshcar and Keidar, Idit and Rhodes, Lee and Serviansky, Hadar},
title = {Fast Concurrent Data Sketches},
year = {2020},
isbn = {9781450368186},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3332466.3374512},
booktitle = {Proceedings of the 25th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {117–129},
numpages = {13}
}


@inproceedings{mergeables_summaries,
author = {Agarwal, Pankaj K. and Cormode, Graham and Huang, Zengfeng and Phillips, Jeff and Wei, Zhewei and Yi, Ke},
title = {Mergeable Summaries},
year = {2012},
isbn = {9781450312486},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2213556.2213562},
doi = {10.1145/2213556.2213562},
booktitle = {Proceedings of the 31st ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems},
pages = {23–34},
numpages = {12},
keywords = {summaries, streaming algorithms},
location = {Scottsdale, Arizona, USA},
series = {PODS '12}
}

@inproceedings{optimal_quantile,
  author={Karnin, Zohar and Lang, Kevin and Liberty, Edo},
  booktitle={2016 IEEE 57th Annual Symposium on Foundations of Computer Science (FOCS)}, 
  title={Optimal Quantile Approximation in Streams}, 
  year={2016},
  volume={},
  number={},
  pages={71-78},
  doi={10.1109/FOCS.2016.17}
  }

@inproceedings{strong_linearizability,
author = {Golab, Wojciech and Higham, Lisa and Woelfel, Philipp},
title = {Linearizable Implementations Do Not Suffice for Randomized Distributed Computation},
year = {2011},
isbn = {9781450306911},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1993636.1993687},
doi = {10.1145/1993636.1993687},
pages = {373–382},
numpages = {10},
keywords = {atomicity, linearizability, randomized algorithms, adversary models},
location = {San Jose, California, USA},
series = {STOC '11}
}

@inproceedings{Herlihy_1990_linearizability,
author = {Herlihy, Maurice P. and Wing, Jeannette M.},
title = {Linearizability: A Correctness Condition for Concurrent Objects},
year = {1990},
issue_date = {July 1990},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {12},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/78969.78972},
doi = {10.1145/78969.78972},
journal = {ACM Trans. Program. Lang. Syst.},
month = {jul},
pages = {463–492},
numpages = {30}
}

@inproceedings{attiya2019putting,
      title={Putting Strong Linearizability in Context: Preserving Hyperproperties in Programs that Use Concurrent Objects}, 
      author={Hagit Attiya and Constantin Enea},
      year={2019},
      eprint={1905.12063},
      archivePrefix={arXiv},
      primaryClass={cs.DC}
}

@inproceedings{Greenwald2001_online_computation,
author = {Greenwald, Michael and Khanna, Sanjeev},
title = {Space-Efficient Online Computation of Quantile Summaries},
year = {2001},
isbn = {1581133324},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/375663.375670},
doi = {10.1145/375663.375670},
booktitle = {Proceedings of the 2001 ACM SIGMOD International Conference on Management of Data},
pages = {58–66},
numpages = {9},
location = {Santa Barbara, California, USA},
series = {SIGMOD '01}
}




@article{10.1145/1379022.1375591,
author = {Boehm, Hans-J. and Adve, Sarita V.},
title = {Foundations of the C++ Concurrency Memory Model},
year = {2008},
issue_date = {June 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/1379022.1375591},
doi = {10.1145/1379022.1375591},
abstract = {Currently multi-threaded C or C++ programs combine a single-threaded programming language with a separate threads library. This is not entirely sound [7].We describe an effort, currently nearing completion, to address these issues by explicitly providing semantics for threads in the next revision of the C++ standard. Our approach is similar to that recently followed by Java [25], in that, at least for a well-defined and interesting subset of the language, we give sequentially consistent semantics to programs that do not contain data races. Nonetheless, a number of our decisions are often surprising even to those familiar with the Java effort:We (mostly) insist on sequential consistency for race-free programs, in spite of implementation issues that came to light after the Java work.We give no semantics to programs with data races. There are no benign C++ data races.We use weaker semantics for trylock than existing languages or libraries, allowing us to promise sequential consistency with an intuitive race definition, even for programs with trylock.This paper describes the simple model we would like to be able to provide for C++ threads programmers, and explain how this, together with some practical, but often under-appreciated implementation constraints, drives us towards the above decisions.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {68–78},
numpages = {11},
keywords = {memory consistency, sequential consistency, data race, memory model, c++, trylock}
}


@inproceedings{Boehm_2008_cpp_concurrency,
author = {Boehm, Hans-J. and Adve, Sarita V.},
title = {Foundations of the C++ Concurrency Memory Model},
year = {2008},
isbn = {9781595938602},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1375581.1375591},
doi = {10.1145/1375581.1375591},
booktitle = {Proceedings of the 29th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {68–78},
numpages = {11},
keywords = {sequential consistency, memory model, c++, trylock, data race, memory consistency},
location = {Tucson, AZ, USA},
series = {PLDI '08}
}

@inproceedings{Haosen_2018_IBR,
author = {Wen, Haosen and Izraelevitz, Joseph and Cai, Wentao and Beadle, H. Alan and Scott, Michael L.},
title = {Interval-Based Memory Reclamation},
year = {2018},
isbn = {9781450349826},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3178487.3178488},
doi = {10.1145/3178487.3178488},
booktitle = {Proceedings of the 23rd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {1–13},
numpages = {13},
keywords = {garbage collection, parallel algorithms, shared memory},
location = {Vienna, Austria},
series = {PPoPP '18}
}


@article{10.1145/2480359.2429109,
author = {Henzinger, Thomas A. and Kirsch, Christoph M. and Payer, Hannes and Sezgin, Ali and Sokolova, Ana},
title = {Quantitative Relaxation of Concurrent Data Structures},
year = {2013},
issue_date = {January 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {48},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2480359.2429109},
doi = {10.1145/2480359.2429109},
abstract = {There is a trade-off between performance and correctness in implementing concurrent data structures. Better performance may be achieved at the expense of relaxing correctness, by redefining the semantics of data structures. We address such a redefinition of data structure semantics and present a systematic and formal framework for obtaining new data structures by quantitatively relaxing existing ones. We view a data structure as a sequential specification S containing all "legal" sequences over an alphabet of method calls. Relaxing the data structure corresponds to defining a distance from any sequence over the alphabet to the sequential specification: the k-relaxed sequential specification contains all sequences over the alphabet within distance k from the original specification. In contrast to other existing work, our relaxations are semantic (distance in terms of data structure states). As an instantiation of our framework, we present two simple yet generic relaxation schemes, called out-of-order and stuttering relaxation, along with several ways of computing distances. We show that the out-of-order relaxation, when further instantiated to stacks, queues, and priority queues, amounts to tolerating bounded out-of-order behavior, which cannot be captured by a purely syntactic relaxation (distance in terms of sequence manipulation, e.g. edit distance). We give concurrent implementations of relaxed data structures and demonstrate that bounded relaxations provide the means for trading correctness for performance in a controlled way. The relaxations are monotonic which further highlights the trade-off: increasing k increases the number of permitted sequences, which as we demonstrate can lead to better performance. Finally, since a relaxed stack or queue also implements a pool, we actually have new concurrent pool implementations that outperform the state-of-the-art ones.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {317–328},
numpages = {12},
keywords = {costs, (concurrent) data structures, relaxed semantics, quantitative models}
}

@inproceedings{Henzinger_2013_Quantitative_Relaxation,
author = {Henzinger, Thomas A. and Kirsch, Christoph M. and Payer, Hannes and Sezgin, Ali and Sokolova, Ana},
title = {Quantitative Relaxation of Concurrent Data Structures},
year = {2013},
isbn = {9781450318327},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2429069.2429109},
doi = {10.1145/2429069.2429109},
booktitle = {Proceedings of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {317–328},
numpages = {12},
keywords = {costs, relaxed semantics, quantitative models, (concurrent) data structures},
location = {Rome, Italy},
series = {POPL '13}
}

@inproceedings{Afek_2010_Quasi_linearizability,
author = {Afek, Yehuda and Korland, Guy and Yanovsky, Eitan},
year = {2010},
month = {12},
pages = {395-410},
title = {Quasi-Linearizability: Relaxed Consistency for Improved Concurrency},
volume = {6490},
isbn = {978-3-642-17652-4},
doi = {10.1007/978-3-642-17653-1_29}
}

@inproceedings{Alistarh_2018_Distributionally_ƒLinearizable,
author = {Alistarh, Dan and Brown, Trevor and Kopinsky, Justin and Li, Jerry Z. and Nadiradze, Giorgi},
title = {Distributionally Linearizable Data Structures},
year = {2018},
isbn = {9781450357999},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3210377.3210411},
doi = {10.1145/3210377.3210411},
booktitle = {Proceedings of the 30th on Symposium on Parallelism in Algorithms and Architectures},
pages = {133–142},
numpages = {10},
location = {Vienna, Austria},
series = {SPAA '18}
}


@inproceedings{guerraoui2020efficient,
  title={Efficient Multi-Word Compare and Swap},
  author={Guerraoui, Rachid and Kogan, Alex and Marathe, Virendra J and Zablotchi, Igor},
  booktitle={34th International Symposium on Distributed Computing},
  year={2020}
}

@inproceedings{Harris2002practical,
author = {Harris, Timothy L. and Fraser, Keir and Pratt, Ian A.},
title = {A Practical Multi-Word Compare-and-Swap Operation},
year = {2002},
isbn = {3540000739},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the 16th International Conference on Distributed Computing},
pages = {265–279},
numpages = {15},
series = {DISC '02}
}

@inproceedings{Haosen2018ibr,
author = {Wen, Haosen and Izraelevitz, Joseph and Cai, Wentao and Beadle, H. Alan and Scott, Michael L.},
title = {Interval-Based Memory Reclamation},
year = {2018},
isbn = {9781450349826},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3178487.3178488},
doi = {10.1145/3178487.3178488},
abstract = {In this paper we present interval-based reclamation (IBR), a new approach to safe reclamation of disconnected memory blocks in nonblocking concurrent data structures. Safe reclamation is a difficult problem: a thread, before freeing a block, must ensure that no other threads are accessing that block; the required synchronization tends to be expensive. In contrast with epoch-based reclamation, in which threads reserve all blocks created after a certain time, or pointer-based reclamation (e.g., hazard pointers), in which threads reserve individual blocks, IBR allows a thread to reserve all blocks known to have existed in a bounded interval of time. By comparing a thread's reserved interval with the lifetime of a detached but not yet reclaimed block, the system can determine if the block is safe to free. Like hazard pointers, IBR avoids the possibility that a single stalled thread may reserve an unbounded number of blocks; unlike hazard pointers, it avoids a memory fence on most pointer-following operations. It also avoids the need to explicitly "unreserve" a no-longer-needed pointer.We describe three specific IBR schemes (one with several variants) that trade off performance, applicability, and space requirements. IBR requires no special hardware or OS support. In experiments with data structure microbenchmarks, it also compares favorably (in both time and space) to other state-of-the-art approaches, making it an attractive alternative for libraries of concurrent data structures.},
booktitle = {Proceedings of the 23rd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {1–13},
numpages = {13},
keywords = {shared memory, parallel algorithms, garbage collection},
location = {Vienna, Austria},
series = {PPoPP '18}
}

@article{alistarh2016lock,
  title={Are lock-free concurrent algorithms practically wait-free?},
  author={Alistarh, Dan and Censor-Hillel, Keren and Shavit, Nir},
  journal={Journal of the ACM (JACM)},
  volume={63},
  number={4},
  pages={1--20},
  year={2016},
  publisher={ACM New York, NY, USA}
}

@misc{DataSketches,
	Howpublished = {\url{https://datasketches.apache.org/}},
	Year = {2019},
	Title = {{Apache DataSketches}}
}

@misc{YahooSketches,
	Howpublished = {\url{https://yahooeng.tumblr.com/post/135390948446/data-sketches}},
	Title = {{Fast, Approximate Analysis of Big Data}}}
	

@misc{x86-cas,
	Howpublished = {\url{https://c9x.me/x86/html/file_module_x86_id_41.html}},
	Year = {Accessed: March 2022},
	Title = {Compare and Exchange}
}

@misc{x86-faa,
	Howpublished = {\url{https://c9x.me/x86/html/file_module_x86_id_327.html}},
 	Year = {Accessed: March 2022},
	Title = {{Exchange and Add}}
}

@InProceedings{rinberg_et_al:LIPIcs:2020:13080,
  author =	{Arik Rinberg and Idit Keidar},
  title =	{{Intermediate Value Linearizability: A Quantitative Correctness Criterion}},
  booktitle =	{34th International Symposium on Distributed Computing (DISC 2020)},
  pages =	{2:1--2:17},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-168-9},
  ISSN =	{1868-8969},
  year =	{2020},
  volume =	{179},
  editor =	{Hagit Attiya},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/opus/volltexte/2020/13080},
  URN =		{urn:nbn:de:0030-drops-130801},
  doi =		{10.4230/LIPIcs.DISC.2020.2},
  annote =	{Keywords: concurrency, concurrent objects, linearizability}
}


@inproceedings{stylianopoulos2020delegation,
  title={Delegation sketch: a parallel design with support for fast and accurate concurrent operations},
  author={Stylianopoulos, Charalampos and Walulya, Ivan and Almgren, Magnus and Landsiedel, Olaf and Papatriantafilou, Marina},
  booktitle={Proceedings of the Fifteenth European Conference on Computer Systems},
  pages={1--16},
  year={2020}
}

@misc{spark,
  author={Spark}, 
  title = {{Apache Spark}},
  howpublished = {\url{https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.sql.DataFrame.approxQuantile.html}},
  year = "Accessed February 16, 2022"
}



@misc{presto,
  author={Presto}, 
  title = {{PrestoDB}},
  howpublished = {\url{https://prestodb.io/docs/current/functions/aggregate.html}},
  year = "Accessed February 16, 2022"
}


@misc{druid-quantiles,
  author={Druid}, 
  title = {{Apache Druid}},
  howpublished = {\url{https://druid.apache.org/docs/latest/development/extensions-core/datasketches-quantiles.html}},
  year = "Accessed February 16, 2022"
}

@article{budiu2019hillview,
  title={Hillview: a trillion-cell spreadsheet for big data},
  author={Budiu, Mihai and Gopalan, Parikshit and Suresh, Lalith and Wieder, Udi and Kruiger, Han and Aguilera, Marcos K},
  journal={Proceedings of the VLDB Endowment},
  volume={12},
  number={11},
  pages={1442--1457},
  year={2019},
  publisher={VLDB Endowment}
}


https://druid.apache.org/docs/latest/development/extensions-core/datasketches-quantiles.html


@inproceedings{Boehm_2008_cpp,
author = {Boehm, Hans-J. and Adve, Sarita V.},
title = {Foundations of the C++ Concurrency Memory Model},
year = {2008},
isbn = {9781595938602},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1375581.1375591},
doi = {10.1145/1375581.1375591},
abstract = {Currently multi-threaded C or C++ programs combine a single-threaded programming language with a separate threads library. This is not entirely sound [7].We describe an effort, currently nearing completion, to address these issues by explicitly providing semantics for threads in the next revision of the C++ standard. Our approach is similar to that recently followed by Java [25], in that, at least for a well-defined and interesting subset of the language, we give sequentially consistent semantics to programs that do not contain data races. Nonetheless, a number of our decisions are often surprising even to those familiar with the Java effort:We (mostly) insist on sequential consistency for race-free programs, in spite of implementation issues that came to light after the Java work.We give no semantics to programs with data races. There are no benign C++ data races.We use weaker semantics for trylock than existing languages or libraries, allowing us to promise sequential consistency with an intuitive race definition, even for programs with trylock.This paper describes the simple model we would like to be able to provide for C++ threads programmers, and explain how this, together with some practical, but often under-appreciated implementation constraints, drives us towards the above decisions.},
booktitle = {Proceedings of the 29th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {68–78},
numpages = {11},
keywords = {trylock, sequential consistency, memory consistency, c++, memory model, data race},
location = {Tucson, AZ, USA},
series = {PLDI '08}
}


@inproceedings{Herlihy_1993_Transactional,
author = {Herlihy, Maurice and Moss, J. Eliot B.},
title = {Transactional Memory: Architectural Support for Lock-Free Data Structures},
year = {1993},
isbn = {0818638109},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/165123.165164},
doi = {10.1145/165123.165164},
abstract = {A shared data structure is lock-free if its operations do not require mutual exclusion. If one process is interrupted in the middle of an operation, other processes will not be prevented from operating on that object. In highly concurrent systems, lock-free data structures avoid common problems associated with conventional locking techniques, including priority inversion, convoying, and difficulty of avoiding deadlock. This paper introduces transactional memory, a new multiprocessor architecture intended to make lock-free synchronization as efficient (and easy to use) as conventional techniques based on mutual exclusion. Transactional memory allows programmers to define customized read-modify-write operations that apply to multiple, independently-chosen words of memory. It is implemented by straightforward extensions to any multiprocessor cache-coherence protocol. Simulation results show that transactional memory matches or outperforms the best known locking techniques for simple benchmarks, even in the absence of priority inversion, convoying, and deadlock.},
booktitle = {Proceedings of the 20th Annual International Symposium on Computer Architecture},
pages = {289–300},
numpages = {12},
location = {San Diego, California, USA},
series = {ISCA '93}
}

@article{rodgers1985improvements,
  title={Improvements in multiprocessor system design},
  author={Rodgers, David P},
  journal={ACM SIGARCH Computer Architecture News},
  volume={13},
  number={3},
  pages={225--231},
  year={1985},
  publisher={ACM New York, NY, USA}
}


% Lee Rhodes, Kevin Lang, Alexander Saydakov, Justin Thaler, Edo Liberty, and Jon Malkin. Apache DataSketches: A Java software library for streaming data algorithms. Apache License, Version 2.0, 2015. https://datasketches.apache.org.


@misc{KDD_tutorial,
  author={Daniel Ting, Jonathan Malkin, Lee Rhodes}, 
  title = {{Data Sketching for Real Time Analytics: Theory and Practice}},
  howpublished = {\url{https://datasketches.apache.org/docs/Community/KDD_Tutorial_Summary.html}},
  year = {2020},
  month={08}
}

@misc{flurry_case,
  author={Daniel Ting, Jonathan Malkin, Lee Rhodes}, 
  title = {{Practical Sketching for Production Systems}},
  howpublished = {\url{https://datasketches.apache.org/docs/img/Community/KDD_sketching_tutorial_pt2.pdf}},
  year = {2020},
  month={08},
  note={{26th ACM SIGKDD conference on knowledge discovery and data mining}}
}

@misc{flurry,
  author={Flurry}, 
  title = {{Flurry}},
  howpublished = {\url{https://www.flurry.com/}},
  year = "Accessed September 22, 2022"
}

